<div class="route route-overview.getting-started.fixture-setup">
    <section>
        <h1>Fixture Setup</h1>
        <p>In your IDE, look at the folder <span class="code">/rocking-form/src/ui/app/services/products-services</span>. This is what we generated before when we said we wanted a service called <span class="code">products</span>. It became <span class="code">ProductsService</span> for convention. Open up the <span class="code">products-service.fixture.js</span>.</p>
        <p>Scaffi uses fixtures to inject mock data into the UI that you can then modify and change so that testing code without a server is feasible. Replace the COLLECTIONS array with this:</p>

        <code-example type="json" code="vm.getSampleData1()"></code-example>

        <p>Think of this as a table record converted to JSON. If you made an actual request to a server, because we work in mostly all JSON, you’d get a structure that looks exactly like this if your table had four columns (id, Name, Description, IsComplete). Once you save that, your page should refresh and look like so:</p>

        <img src="images/getting-started-fixture-1st.png" />

        <p>If you look at the object structure we put in the fixture.js file and the <span class="code">products-index.html</span> file, you should be able to see the direct correlation between the two files. </p>
        <p>To explain what’s happening here: when the app loads, if it’s in prototype mode, it loads any fixture collections into memory. Then, when it sees certain requests made by a service, it filters the service’s fixtures for what data it can pull and returns it to the page controller as if it were making a server request. </p>
        <p>If we add another fixture:</p>

        <code-example type="json" code="vm.getSampleData2()"></code-example>

        <p>The page should now look like so:</p>

        <img src="images/getting-started-fixture-2nd.png" />

        <p>Super cool right?</p>
        <p>As you build pages and forms, be sure to maintain at least one test fixture structure per service. Doing so has the following benefits and in fact, this will be a coding practice we need to follow:</p>

        <ul class="list">
            <li>You’ll be able to test the display output of data on a page by simply modifying your fixture structure</li>
            <li>Fixtures provide a referenceable data structure for anyone looking at your code</li>
            <li>Once you’re done with the prototype stage, if you have maintained an example set of fixtures, building your database schema will be cake walk because you won’t have to dig through html templates, trying to figure out what variables you used. You can look at your objects and build the schema with ease (We'll be doing this a bit later).</li>
            <li>With fixtures, you’ll be able to run integration tests off of them so that you can test your forms for bugs without the usual manual drawl of testing by code-refresh-code-refresh.</li>
        </ul>

        <p class="alert">!!! When you’re going through the prototype stage and building out your data structures, make sure to use good clear names so that you don’t have to clean them up later. If you're working with a DBA that's dictating the schema structure, make sure you agree on naming conventions and data points before you start coding, otherwise you'll be redoing stuff. !!!</p>

        <p>Maintaining fixture examples will make everyone on the project happy, so when you change a form or a display stub, remember to update your fixture as well.</p>
        <p>We don’t just display data though, right? We do lots of forms and edit lots of data structures, so let’s see how that works in prototype mode without a server.</p>

    </section>
    <section layout="row">
        <md-button ui-sref="app.overview.getting-started.route-setup"><i class="fa fa-arrow-left"></i> Route Setup</md-button>
        <div flex></div>
        <md-button ui-sref="app.overview.getting-started.editing-fixtures">Manipulate Fixtures <i class="fa fa-arrow-right"></i></md-button>
    </section>
</div>